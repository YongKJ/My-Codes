#include <iostream>
using namespace std;
int main(){
	int n;
	while(cin>>n){
		int a[101][101]={0},d[101][101]={-1};
		for(int i=1;i<=n;i++)
			for(int j=1;j<=i;j++){
				cin>>a[i][j];
				if(i==n)d[i][j]=a[i][j];
			}
		for(int i=n-1;i>=1;i--)
			for(int j=1;j<=i;j++)
				d[i][j]=a[i][j]+max(d[i+1][j],d[i+1][j+1]);
		cout<<d[1][1]<<endl;
	}
	return 0;
}
/*
设有一个三角形的数塔，顶点为根结点，每个结点有一个整数值。从顶点出发，可以向左走或向右走，如图所示：
 
要求从根结点开始，请找出一条路径，使路径之和最大，只要输出路径的和。
输入：
代表N层，接下来输入第1-N层的数据(1 <= N <= 100)
输出：
对于每个测试实例，输出可能得到的最大和，每个实例的输出占一行
样例输入：（样例与图例不是相同树）
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5
样例输出：
30

*/
