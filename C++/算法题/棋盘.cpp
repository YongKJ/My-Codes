//深搜：每次向上下左右四个方向搜
//为避免超时，加上记忆化剪枝d和bl 

#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>

using namespace std;

int i,m,n,j,k,q,p,w;
int a[1100][1100];//保存位置颜色
int f[4]={0,0,1,-1},ff[4]={1,-1,0,0};//四个搜索方向，分别表示横纵坐标变化值 
int minn=0x7fffffff;//花费最小值 
int d[1100][1100];//剪枝1：保存每个位置的花费最小值 
bool bl[1100][1100];//剪枝2：保存每个位置是否走过 

void search(int x,int y,int c,int color)
//x，y为当前位置坐标 ，c为当前所花金币，color为当前位置颜色 
{
    if((x==n)&&(y==n))//已搜到右下角，即（n,n) 
    {
        minn=min(c,minn);//用min保存到(n,n)的最小花费 
        return;
    }

    for(int i=0;i<4;i++)//向四个方向搜索 
    {
        int p=x+f[i],q=y+ff[i];//移动后到达的位置 
        if((p<=n)&&(p>0)&&(q<=n)&&(q>0))//判断搜索位置合法，未超出边界 
        if(bl[p][q])//判断搜索位置未走过
        if(a[x][y]||a[p][q])//判断搜索位置和当前位置至少其中一个有颜色 
        {
            if(a[p][q]==0)//如果搜索位置没有颜色，变色为当前颜色
            {
                if(c+2<d[p][q])//剪枝：花费2金币和原本到此的最小花费 
                { 
                    bl[p][q]=0;//将此位置设为已走 
                    d[p][q]=c+2,search(p,q,c+2,color);//更新搜索位置的最小花费，递归 
                    bl[p][q]=1;//回溯 
                } 
            }
            else//搜索位置有颜色 
            {
                if((color==a[p][q])&&(c<d[p][q]))//搜索位置与原位置颜色相同，且花费减少
                { 
                    bl[p][q]=0;//将此位置设为已走 
                    d[p][q]=c,search(p,q,c,color);//更新搜索位置的最小花费，递归
                    bl[p][q]=1;//回溯 
                } 
                else if((c+1<minn)&&(c+1<d[p][q])) //搜索位置与原位置颜色不同        
                { 
                    bl[p][q]=0;//将此位置设为已走 
                    d[p][q]=c+1,search(p,q,c+1,a[p][q]);//更新搜索位置的最小花费，递归
                    bl[p][q]=1;//回溯
                }
            }
        }
    }
}

int main()
{
    scanf("%d%d",&n,&m);

    for(i=1;i<=n;i++)
        for(j=1;j<=n;j++) d[i][j]=0x7fffffff,a[i][j]=0,bl[i][j]=1;

    for (i = 1; i <= m; i++) {
      scanf("%d%d%d", &q, &p, &w);
      a[q][p] = w + 1; //把有颜色分别存为1，2 。无色存为0
    }

    bl[1][1] = 0; //开始位置设为走过

    search(1, 1, 0, a[1][1]);

    if (minn == 0x7fffffff)
      printf("-1"); //没有找到输出-1
    else
      printf("%d", minn);

    return 0;
}
/*
题目描述

有一个mmm×m的棋盘，棋盘上每一个格子可能是红色、
黄色或没有任何颜色的。你现在要从棋盘的最左上角走
到棋盘的最右下角。

任何一个时刻，你所站在的位置必须是有颜色的
（不能是无色的）， 你只能向上、 下、左、 右四个方向
前进。当你从一个格子走向另一个格子时，如果两个格子
的颜色相同，那你不需要花费金币；如果不同，则你需要
花费 11个金币。

另外， 你可以花费 22 个金币施展魔法让下一个无色格子
暂时变为你指定的颜色。但这个魔法不能连续使用， 而且
这个魔法的持续时间很短，也就是说，如果你使用了这个
魔法，走到了这个暂时有颜色的格子上，你就不能继续使
用魔法； 只有当你离开这个位置，走到一个本来就有颜色
的格子上的时候，你才能继续使用这个魔法，而当你离开了
这个位置（施展魔法使得变为有颜色的格子）时，这个格子恢
复为无色。

现在你要从棋盘的最左上角，走到棋盘的最右下角，求花费的
最少金币是多少？

输入输出格式

输入格式：
第一行包含两个正整数mnm,n，以一个空格分开，分别代表棋盘
的大小，棋盘上有颜色的格子的数量。

接下来的nn行，每行三个正整数xycx,y,c， 分别表示坐标为xy(x,y)
的格子有颜色cc。

其中c1c=1 代表黄色，c0c=0 代表红色。 相邻两个数之间用一个空
格隔开。 棋盘左上角的坐标为11(1,1)，右下角的坐标为mm(m,m)。

棋盘上其余的格子都是无色。保证棋盘的左上角，也就是11(1,1) 
一定是有颜色的。

输出格式：
一个整数，表示花费的金币的最小值，如果无法到达，输出1−1。

输入输出样例

输入样例#1： 复制
5 7
1 1 0
1 2 0
2 2 1
3 3 1
3 4 0
4 4 1
5 5 0
输出样例#1： 复制
8
输入样例#2： 复制
5 5
1 1 0
1 2 0
2 2 1
3 3 1
5 5 0
输出样例#2： 复制
-1
*/