#include <iostream>
using namespace std;
int main() {
  int n,s;
  while (s = 3, cin >> n) {
    for (int i = 1, t = 2, j = 0, k = 3; i <= n - 3; i++) {
      s += t, j++;
      if (j == k)
        t *= 2, j = 0, k++;
    }
    s *= 2;
    if (n == 1)
      cout << 1 << endl;
      else if(n==2)
        cout << 3 << endl;
    	else
      	cout << --s << endl;
  }
  return 0;
}
/*
1  1    1

1 1   2     2
1     3

1 1 1    3     3
 1 1     5

2 1 1 1   5     4
2 1 1     9

2 2 1 1 1    7     5
2 2 1 1     13

2 2 2 1 1 1     9	6
2 2 2 1 1      17

4 2 2 2 1 1 1    13	7
4 2 2 2 1 1     25

4 4 2 2 2 1 1 1    17	8
4 4 2 2 2 1 1     33

4 4 4 2 2 2 1 1 1    21		9
4 4 4 2 2 2 1 1     41

4 4 4 4 2 2 2 1 1 1    25	10
4 4 4 4 2 2 2 1 1     49

8 4 4 4 4 2 2 2 1 1 1     33	11
8 4 4 4 4 2 2 2 1 1      65

8 8 4 4 4 4 2 2 2 1 1 1     41		12
8 8 4 4 4 4 2 2 2 1 1      81

8 8 8 4 4 4 4 2 2 2 1 1 1     49	13
8 8 8 4 4 4 4 2 2 2 1 1      97

8 8 8 8 4 4 4 4 2 2 2 1 1 1     57	14
8 8 8 8 4 4 4 4 2 2 2 1 1      113

8 8 8 8 8 4 4 4 4 2 2 2 1 1 1     65	15
8 8 8 8 8 4 4 4 4 2 2 2 1 1      129

16 8 8 8 8 8 4 4 4 4 2 2 2 1 1 1     81	16
16 8 8 8 8 8 4 4 4 4 2 2 2 1 1      161


描述


    经典的汉诺塔问题经常作为一个递归的经典例题存在。可能有人并不知道汉诺塔问题的典故。汉诺塔来源于印度传说的一个故事，上帝创造世界时作了三根金刚石柱子，在一根柱子上从下往上按大小顺序摞着64片黄金圆盘。上帝命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一回只能移动一个圆盘。有预言说，这件事完成时宇宙会在一瞬间闪电式毁灭。也有人相信婆罗门至今仍在一刻不停地搬动着圆盘。恩，当然这个传说并不可信，如今汉诺塔更多的是作为一个玩具存在。Gardon就收到了一个汉诺塔玩具作为生日礼物。 
    现在加有第四个柱子时，问需要多少次呢？
输入

包含多组数据，每个数据一行，是盘子的数目N(1<=N<=64)。

输出

对于每组数据，输出一个数，到达目标需要的最少的移动数。

样例输入

1
3

样例输出

1
5
*/