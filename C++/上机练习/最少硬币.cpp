//硬币问题就是一个多重背包问题
//动态迁移方程为 dp[k] = min{dp[k-t[i]]+1,dp[k]}
//就是，将第i个硬币拿出去得到的一个最少的找硬币数+1，和原硬币数相比最小的那个就是结果
//另外一种思路，可以将所有的硬币价值都放在一个数组，就变成了0-1背包问题，所需考虑的就是放不放的问题

#include<iostream>
using namespace std;
int min(int a,int b);
int main()
{
   int n; //n种不同面值的硬币
   int m;
   int i , j ,k;
  // cout<<"请输入有几种不同的面值:";
   cin>>n;
   int *t =new int[n+1];               //硬币的面值存放在t数组中 -- 价值
   int *coin = new int [n+1];      //可以使用的硬币个数存放在coin中--个数
   //cout<<"请输入"<<n<<"组硬币的面值和对应的个数（中间用空格隔开）:"<<endl;
   for(i = 1 ;i<n+1;i++)
       cin>>t[i]>>coin[i];
   //cout<<"请输入要找的钱数m:";
   cin>>m;
   int dp[20002]={0} ;   //dp[i] 用来记录钱数为i时的最少的硬币数
   for(i=1;i<=m;i++)
       dp[i] = 99999;
   //dp[0] = 0;
   for(i = 1 ;i <= n ; i++)    //硬币面值的种数
       for(j = 1 ; j <= coin[i] ; j++)   //硬币的面值的个数
           for( k = m ; k >= t[i] ;  k-- )    
           {
               dp[k] = min(dp[k-t[i]] +1,dp[k]);
               //cout<<k<<": "<<dp[k]<<endl;  用于测试使用
           }
 //  cout<<"最少需要用到的硬币个数是:";
   if(dp[m] == 99999)cout<<-1<<endl;
   else cout<<dp[m]<<endl;
}

int min(int a, int b) { return a < b ? a : b; }
/*
描述

    设有n 种不同面值的硬币，各硬币的面值存于数组T［1:n］中。现要用
    这些面值的硬币来找钱。可以使用的各种面值的硬币个数存于数组
    Coins［1:n］中。对任意钱数0≤m≤20001，设计一个用最少硬币
    找钱m的方法。

输入

  输入的第一行中只有1 个整数给出n的值,第2 行起每行2 个数，
  分别是T[j]和Coins[j]。最后1 行是要找的钱数m。

输出

   程序运行结束时，将计算出的最少硬币数输出。问题无解时输出-1。

样例输入

3
1 3
2 3
5 3
18

样例输出

5

提示

多重背包。
*/