#include <iostream>
using namespace std;
int main(){
  int n;
  cin >> n;
  while(n--){
    int m, t, sum = 0;
    cin >> m;
    int s[m];
    for (int i = 0; i < m; i++)
      cin >> s[i];
    for (int i=0;i<m;i++)
      for (int j=i+1;j<m;j++)
        if (s[i] < s[j]) 
          t = s[i], s[i] = s[j], s[j] = t;
    for (int i = 0, j = 1; j < m; i+=2, j+=2) {
      if (s[i] == 1 || s[j] == 1 || s[i] == 0 || s[j] == 0)
        sum += s[i] + s[j];
      else
        sum += s[i] * s[j];
    }
    if(m%2!=0)
      sum += s[m - 1];
    cout << sum << endl;
  }
  return 0;
}
/*

江鸟想到一个有趣的问题：给你N个正整数，
你可以将这N个整数按两个一组的方式成对划分，
当然其中的元素也可以不和其他元素配对划分。
现在的问题是，让划分为一对的元素的乘积与
未配对的元素相加求和，并且让和最大。比如：
考虑这个集合{0,1,2,4,5,3}，如果我们让{0,3}、{2,5}
分别成一对，那么得到的和为：1+4+(0*3)+(2*5)=15,
当然这不是最大值，如果这样划分{4,5}、{2，3}分别
一组，我们得到的和为：(4*5)+(2*3)+1+0=27,此时
得到的和为最大了。

输入

第一行输入一个数case代表下面测试数据的总数。
以下每个case由两行组成：第一行输入N，
代表有N个整数(1<=N<=100)第二行输入这N个整数。
(每个整数都小于100)

输出

输出每个case对应的最大和。

样例输入

2
6
0 1 2 3 4 5 
1
3

样例输出

27
3
*/